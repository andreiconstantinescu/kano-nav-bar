<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../kano-circle-progress/kano-circle-progress.html">
<!--

`kano-user-badge` is a simple tooltip like user-badge box

Example:

    <kano-user-badge user="[[user]]" xp="700"></kano-user-badge>
    <kano-user-badge user="[[user]]" xp="2100" default-avatar="/my-default-avatar.png"></kano-user-badge>

Custom property | Description | Default
----------------|-------------|----------
`--kano-user-badge` | Mixin applied to the badge | `{}`
`--kano-user-badge-progress-color` | Color of the progress circle | `#ff842a`

@group Kano Elements
@hero hero.svg
@demo demo/kano-user-badge.html
-->
<dom-module is="kano-user-badge">
    <style>
        :host {
            display: block;
            box-sizing: border-box;
        }

        :host kano-circle-progress {
            width: 60px;
            height: 60px;
            --kano-circle-progress: {
                stroke: var(--kano-user-badge-progress-color, #ff842a);
            }
        }

        :host .content {
            position: relative;
            border-radius: 100%;
            height: 60px;
            width: 60px;
            @apply(--kano-user-badge);
        }

        /* TODO Use CSS variable when kano-circle-progress will support it */
        :host ::content kano-circle-progress svg #circle-full {
            display: block !important;
        }

        :host .user-avatar {
            position: absolute;
            top: 0px;
            margin: 8px;
            border: 0.1em solid white;
            border-radius: 50%;
            width: 42px;
            height: 42px;
        }

    </style>
    <template>
        <div class="content">
            <kano-circle-progress value="[[progress]]" stroke-width="8" radius="60"></kano-circle-progress>
            <img src="[[avatar]]" class="user-avatar" />
        </div>
    </template>
</dom-module>
<script>
    Polymer({
        is: 'kano-user-badge',
        properties: {
            /**
             * The kano world user object
             */
            user: {
                type: Object
            },
            /**
             * Experience gained by the user
             */
            xp: {
                type: Number,
                value: 0
            },
            /**
             * Current progress of the user fomr 0 to 1 until the next level
             */
            progress: {
                type: Number,
                computed: '_computeProgress(xp)',
                readOnly: true,
                notify: true
            },
            /**
             * Source of the user's avatar or the default avatar
             */
            avatar: {
                type: String,
                computed: '_computeAvatar(user)',
                readOnly: true,
                notify: true
            },
            level: {
                type: Number,
                computed: '_computeLevel(xp)',
                readOnly: true,
                notify: true
            },
            /**
             * Fallback image to display
             */
            defaultAvatar: {
                type: String,
                value: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
            }
        },
        created () {
            this.levelsMap = {
                "1": 0,
                "2": 150,
                "3": 300,
                "4": 500,
                "5": 800,
                "6": 1300,
                "7": 1600,
                "8": 2200,
                "9": 3000
            };
        },
        _computeAvatar(user) {
            if (user && user.avatar && user.avatar.urls) {
                return user.avatar.urls.circle || this.defaultAvatar;
            }
            return this.defaultAvatar;
        },
        _computeLevel (xp) {
            let current = 1,
                lvl;

            if (typeof xp !== 'number') {
                return null;
            }
            for (lvl in this.levelsMap) {
                if (xp < this.levelsMap[lvl]) {
                    return parseInt(current);
                }
                current = lvl;
            }
            return parsetInt(current);
        },
        _progressFromXp (xp) {
            let last = 0,
                lvl;

            for (lvl in this.levelsMap) {
                if (xp < this.levelsMap[lvl]) {
                    return [xp - last, this.levelsMap[lvl] - xp, this.levelsMap[lvl] - last];
                }
                last = this.levelsMap[lvl];
            }

            return 0;
        },
        _percentFromXp (xp) {
            let progress = this._progressFromXp(xp),
                covered = progress[0],
                leap = progress[2];

            return (covered * 100) / leap;
        },
        _computeProgress(xp) {
            return this._percentFromXp(xp) / 100;
        }
    });
</script>
